import csv
import json
import os
from datetime import datetime
from math import ceil, floor

from SysConfig import SysConfig
from cfr import VanillaCFR
from exp.network_generators import gen_new_network
from exp.root_generators import FlashCrashRootGenerator, SearchRootGenerator
from split_game_cfr import SplitGameCFR


def compute_complete_game_equilibrium(complete_game_root, attacker_budgets, iterations):
    vanilla_cfr = VanillaCFR(complete_game_root)
    vanilla_cfr.run(iterations=iterations)
    vanilla_cfr.compute_nash_equilibrium()
    defender_eq = vanilla_cfr.value_of_the_game()
    attackers_eq = {}
    regrets = {}
    root =vanilla_cfr.root
    for attacker in attacker_budgets:
        attackers_eq[attacker] = root.children[str(attacker)].get_value()
        regrets[attacker] = vanilla_cfr.cumulative_regrets[root.children[str(attacker)].inf_set()]
    cumulative_pos_regret = vanilla_cfr.average_total_imm_regret(iterations)

    return {'defender':defender_eq, 'attackers':attackers_eq, 'regrets':regrets,
            'pos_regret': cumulative_pos_regret, 'exploitability': 2* cumulative_pos_regret}


def get_split_cfr_exploitabilty(params, root_generator, iterations, main_game_iteration_portion):
    split_game_cfr = SplitGameCFR()
    root = root_generator.get_split_main_game_root()
#    action_mgr = root_generator.get_split_game_action_mgr()

    (main_game_results, selector_game_result) = split_game_cfr.run(main_game_root=root, attacker_types=params['attacker_budgets'],
                                     game1_iterations=ceil(iterations*main_game_iteration_portion),
                                     game2_iterations=ceil(iterations*(1-main_game_iteration_portion)),
                                     attacks_in_budget_dict=root_generator.get_attack_costs(),
                                     subgame_keys=root_generator.get_attack_keys(),
                                     game_2_pure= True )

    return main_game_results['exploitability']+selector_game_result['exploitability']
   # return main_game_results['exploitability']



def get_complete_game_cfr_exp(comlete_game_root, attacker_budgets, iterations):
    results = compute_complete_game_equilibrium(comlete_game_root, attacker_budgets, iterations)
    return results['exploitability']


def iteration_portion_exp_csv(res_dir, defender_budget, attacker_budgets,
                        min_portion, max_portion, jump, num_assets,iterations_num, step_order_size, max_order_num,num_exp=10):
    portion = min_portion
    regrets = []
    iteration_regrets = {}
    for i in range(0, num_exp):
        dirname, network = gen_new_network(num_assets)
        while portion < max_portion:
            if portion not in regrets:
                iteration_regrets[portion] = 0
            split_cfr_exploitability = get_split_cfr_exploitabilty(defender_budget, attacker_budgets, network, step_order_size,
                                                    max_order_num, iterations_num, portion)
            iterations_num += jump
            iteration_regrets[portion] += split_cfr_exploitability

    for it_portion in iteration_regrets.keys():
        regrets.append({'iteration_portion': it_portion, 'regret': iteration_regrets[it_portion] / num_exp})

    with open(res_dir + 'iteration_portion.csv', 'w') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=['num_iterations', 'vanilla_cfr', 'split_cfr'])
        writer.writeheader()
        for row in regrets:
            writer.writerow(row)

def iteration_stats_assets_csv(root_generator, res_dir, params, main_game_iteration_portion,
                        min_iterations, max_iterations, jump, game_size_range, game_name, num_exp=10):
    regrets = []
    iteration_regrets = {}

    iterations_num = min_iterations
    while iterations_num < max_iterations:
        iteration_regrets[iterations_num] = {}
        for game_size in game_size_range:
            iteration_regrets[iterations_num].update({'split_' + str(game_size): 0,
                                                      'vanilla_' + str(game_size): 0,
                                                      'nodes_touched_split_' + str(game_size): 0,
                                                      'nodes_touched_complete_' + str(game_size): 0})
        iterations_num += jump

    for game_size in game_size_range:
        iterations_num = min_iterations
        while iterations_num <= max_iterations:
            for i in range(0, num_exp):
                root_generator.gen_roots(game_size)
                split_cfr_exp = get_split_cfr_exploitabilty(params, root_generator, iterations_num, main_game_iteration_portion)
                vanilla_cfr_exp = get_complete_game_cfr_exp(root_generator.get_complete_game_root(),
                                                            params['attacker_budgets'], iterations_num)
                iteration_regrets[iterations_num]['split_'+str(game_size)] += split_cfr_exp
                iteration_regrets[iterations_num]['vanilla_'+str(game_size)] += vanilla_cfr_exp
                iteration_regrets[iterations_num]['nodes_touched_split_'+str(game_size)] += root_generator.split_root.tree_size*iterations_num
                iteration_regrets[iterations_num]['nodes_touched_complete_'+str(game_size)] += root_generator.complete_root.tree_size*iterations_num
            iterations_num += jump

    for it_num in iteration_regrets.keys():
        row = {'num_iterations':it_num}
        for game_size in game_size_range:
            row.update({'split_cfr_exp_'+str(game_size):iteration_regrets[it_num]['split_'+str(game_size)]/ num_exp,
                        'vanilla_cfr_exp_'+str(game_size): iteration_regrets[it_num]['vanilla_'+str(game_size)]/num_exp,
                        'nodes_touched_split_'+str(game_size): iteration_regrets[it_num]['nodes_touched_split_'+str(game_size)]/num_exp,
                        'nodes_touched_complete_'+str(game_size): iteration_regrets[it_num]['nodes_touched_complete_'+str(game_size)]/num_exp
                        })

        regrets.append(row)

    fieldnames = ['num_iterations']
    for game_size in game_size_range:
        fieldnames.append('vanilla_cfr_exp_'+str(game_size))
        fieldnames.append('split_cfr_exp_'+str(game_size))
        fieldnames.append('nodes_touched_split_'+str(game_size))
        fieldnames.append('nodes_touched_complete_'+str(game_size))

    range_list = list(game_size_range)
    file_name = res_dir + game_name + '_exploitability'
    if len(range_list) ==1:
        file_name += '_' + str(range_list[0])+'.csv'
    else:
        file_name += '.csv'
    with open(res_dir + game_name + '_exploitability.csv','w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for row in regrets:
            writer.writerow(row)


def init_bucket(tree_size, iteration_regrets, iterations_num, game_size):
    bucket = int(floor(tree_size/1000)*1000)*iterations_num
    if bucket not in iteration_regrets  :
        iteration_regrets[bucket] = {}
    iteration_regrets[bucket].update({
                                 'split_' + str(game_size): 0,
                                 'vanilla_' + str(game_size): 0,
                                 'nodes_touched_split_' + str(game_size): 0,
                                 'nodes_touched_complete_' + str(game_size): 0,
                                 'num_iterations_' + str(game_size):iterations_num })
    return bucket


def cmp_exploitability_csv(root_generator, res_dir, params, main_game_iteration_portion,
                        min_iterations, max_iterations, jump, game_size_range, game_name, num_exp=10):
    regrets = []
    iteration_regrets = {}

    for game_size in game_size_range:
        iterations_num = min_iterations
        while iterations_num <= max_iterations:
            for i in range(0, num_exp):
                root_generator.gen_roots(game_size)
                split_cfr_exp = get_split_cfr_exploitabilty(params, root_generator, iterations_num, main_game_iteration_portion)
                vanilla_cfr_exp = get_complete_game_cfr_exp(root_generator.get_complete_game_root(),
                                                            params['attacker_budgets'], iterations_num)
                split_bucket = init_bucket(root_generator.split_root.tree_size, iteration_regrets, iterations_num, game_size)
                complete_bucket = init_bucket(root_generator.complete_root.tree_size, iteration_regrets, iterations_num, game_size)

                iteration_regrets[split_bucket]['split_'+str(game_size)] += split_cfr_exp
                iteration_regrets[complete_bucket]['vanilla_'+str(game_size)] += vanilla_cfr_exp
            iterations_num += jump

    for nodes_touched in iteration_regrets.keys():
        row = {'nodes_touched':nodes_touched}
        for game_size in game_size_range:
            row.update({'split_cfr_exp_'+str(game_size):iteration_regrets[nodes_touched]['split_'+str(game_size)]/ num_exp,
                        'vanilla_cfr_exp_'+str(game_size): iteration_regrets[nodes_touched]['vanilla_'+str(game_size)]/num_exp,
                        'num_iterations_'+str(game_size): iteration_regrets[nodes_touched]['num_iterations_'+str(game_size)]/num_exp
                        })

        regrets.append(row)

    fieldnames = ['nodes_touched']
    for game_size in game_size_range:
        fieldnames.append('vanilla_cfr_exp_'+str(game_size))
        fieldnames.append('split_cfr_exp_'+str(game_size))
        fieldnames.append('num_iterations_'+str(game_size))

    file_name = res_dir + game_name + '_exploitability'
    if len(game_size_range) == 1:
        file_name += '_' + str(game_size_range[0])+'.csv'
    else:
        file_name += '.csv'
    with open(file_name,'w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        for row in regrets:
            writer.writerow(row)

def iteration_stats_csv(res_dir, root_generator, params, main_game_iteration_portion,
                        min_iterations, max_iterations, jump, game_size, game_name, num_exp=10):
    iterations_num = min_iterations
    regrets = []
    iteration_regrets = {}
    iterations_num = min_iterations
    while iterations_num < max_iterations:
        iteration_regrets[iterations_num] = {}
        iteration_regrets[iterations_num].update({'split',
                                                  'vanilla',
                                                  'nodes_touched_split',
                                                  'nodes_touched_complete'})
        iterations_num += jump


    for i in range (0, num_exp):
        while iterations_num < max_iterations:
            root_generator.gen_roots(game_size)
            split_cfr_exp = get_split_cfr_exploitabilty(params, root_generator, iterations_num,
                                                        main_game_iteration_portion)
            vanilla_cfr_exp = get_complete_game_cfr_exp(root_generator.get_complete_game_root(), params['attacker_budgets'], iterations_num)
            iteration_regrets[iterations_num]['split'] += split_cfr_exp
            iteration_regrets[iterations_num]['vanilla'] += vanilla_cfr_exp
            iterations_num += jump

    for it_num in iteration_regrets.keys():
        regrets.append({'num_iterations':it_num,'split_cfr_exp':iteration_regrets[it_num]['split']/ num_exp,
                        'vanilla_cfr_exp': iteration_regrets[it_num]['vanilla']/num_exp})

    with open(res_dir + game_name + '_exploitability_' + str(game_size) +'.csv','w', newline='') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=['num_iterations','vanilla_cfr_exp','split_cfr_exp'])
        writer.writeheader()
        for row in regrets:
            writer.writerow(row)


def setup_dir(game_name):
    dt = datetime.today()
    dt = str(dt).split(' ')[0]
    res_dir = '../../results/stats/' + game_name  +'/'+  dt.replace(":", "_").replace(" ", "_") + '/'
    if not os.path.exists(res_dir):
        os.mkdir(res_dir)

    return res_dir

def run_flash_crash_csv_exps(exp_params):
    res_dir = setup_dir('flash_crash')
    exp_params.update({'defender_budget': 2000000000,
                  'attacker_budgets': [4000000000, 6000000000,  8000000000 ],
                  'main_game_iteration_portion': 0.8,
                  'step_order_size': SysConfig.get("STEP_ORDER_SIZE")*2 ,
                  'max_order_num': 1})

    with open(res_dir+'params.json', 'w') as fp:
        json.dump(exp_params, fp)

    root_generator = FlashCrashRootGenerator(exp_params)

    iteration_stats_assets_csv(res_dir=res_dir,
                        root_generator=root_generator,
                        params = exp_params,
                        main_game_iteration_portion=exp_params['main_game_iteration_portion'],
                        min_iterations=exp_params['min_iterations'],
                        max_iterations=exp_params['max_iterations'],
                        jump=exp_params['jump'],
                        game_size_range=range(3, 4),
                        game_name='flash_crash',
                        num_exp = 1)

    return
    iteration_stats_csv(res_dir=res_dir,
                        root_generator=root_generator,
                        params = exp_params,
                        main_game_iteration_portion=exp_params['main_game_iteration_portion'],
                        min_iterations=exp_params['min_iterations'],
                        max_iterations=exp_params['max_iterations'],
                        jump=exp_params['jump'],
                        game_size= exp_params['num_assets'],
                        game_name='flash_crash')
    #compute_node_size_csv(res_dir=res_dir,  max_num_attackers = 4, max_num_portfolios = 4, portfolio_size = 10)
  #  count_game_nodes_csv(res_dir=res_dir, defender_budget=exp_params['defender_budget'],
  #                      attacker_budgets=exp_params['attacker_budgets'],
  #                      max_num_assets = 5)



def run_search_csv_exps(c):
    res_dir = setup_dir('search')
    exp_params.update({'attacker_budgets':  [4, 5, 11]})

    with open(res_dir+'params.json', 'w') as fp:
        json.dump(exp_params, fp)

    root_generator = SearchRootGenerator(exp_params)
    iteration_stats_assets_csv(res_dir=res_dir,
                               root_generator=root_generator,
                               params=exp_params,
                               main_game_iteration_portion=exp_params['main_game_iteration_portion'],
                               min_iterations=exp_params['min_iterations'],
                               max_iterations=exp_params['max_iterations'],
                               jump=exp_params['jump'],
                               game_size_range=exp_params['game_size_range'],
                               game_name='search',
                               num_exp = 1)
    return
    iteration_stats_csv(res_dir=res_dir,
                        root_generator=root_generator,
                        params = exp_params,
                        main_game_iteration_portion=exp_params['main_game_iteration_portion'],
                        min_iterations=exp_params['min_iterations'],
                        max_iterations=exp_params['max_iterations'],
                        jump=exp_params['jump'],
                        game_size= exp_params['game_size'],
                        game_name='search')


    #compute_node_size_csv(res_dir=res_dir,  max_num_attackers = 4, max_num_portfolios = 4, portfolio_size = 10)
  #  count_game_nodes_csv(res_dir=res_dir, defender_budget=exp_params['defender_budget'],
  #                      attacker_budgets=exp_params['attacker_budgets'],
  #                      max_num_assets = 5)

if __name__ == "__main__":
    exp_params = {'main_game_iteration_portion': 1.0,
                  'min_iterations': 100,
                  'max_iterations': 1001,
                  'game_size_range':list(range(3,4)),
                  'jump': 100,
                  }
    run_flash_crash_csv_exps(exp_params)



